/*
 * Copyright (c) 2016, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * IOTAUTH_COPYRIGHT_VERSION_1
 */

/**
 * IoT secure client helper module.
 * @author Hokeun Kim
 */

"use strict";

var net = require('net');
var dgram = require('dgram');
var crypto = require('crypto');
var util = require('util');

// local modules
var common = require('./common');
var msgType = common.msgType;
var IoTSecureSocket = require('./iotSecureSocket');

///////////////////////////////////////////////////////////////////
////                Functions for entity client                ////
// client communication state
var entityClientCommState = {
    IDLE: 0,
    HANDSHAKE_1_SENT: 10,
    IN_COMM: 30                    // Session message
};
/*
helperOptions = {
    msgType,
    payload,
    myNonce,
    entityClientState
}
*/
/*
helperEventHandlers = {
    onWrite,
    onEnd,
    onConnection
}
*/
/*
ret = {
    success,
    myNonce,
    newSessionKeyVal            
}
*/
var handshakeTimeout = null;
function secureClientHelper(helperOptions, helperEventHandlers, options, eventHandlers) {
    function handshakeTimeoutHandler() {
        handshakeTimeout = null;
        helperEventHandlers.onEnd();
        eventHandlers.onError('Comm init failed: handshake1 timed out ...');
    }
    // send handshake1
    if (helperOptions == null) {
        var myNonce = common.generateHSNonce();
        console.log('chosen nonce: ' + myNonce.inspect());

        var handshake1 = {nonce: myNonce};
        var buf = common.serializeHandshake(handshake1);
        var enc = common.symmetricEncryptAuthenticate(buf, options.sessionKey, options.sessionCryptoSpec);
        var keyIdBuf = Buffer.alloc(common.SESSION_KEY_ID_SIZE);
        common.writeVariableUIntBE(keyIdBuf, options.sessionKey.id, 0, common.SESSION_KEY_ID_SIZE);

        var msg = {
            msgType: msgType.SKEY_HANDSHAKE_1,
            payload: Buffer.concat([keyIdBuf, enc])
        };
        helperEventHandlers.onWrite(common.serializeIoTSP(msg));

        console.log('switching to HANDSHAKE_1_SENT');
        var entityClientState = entityClientCommState.HANDSHAKE_1_SENT;
        if (options.handshakeTimeout == null) {
            throw 'handshakeTimeout is not set!'
        }
        handshakeTimeout = setTimeout(handshakeTimeoutHandler, options.handshakeTimeout);
        return {myNonce: myNonce};
    }
    else if (helperOptions.msgType == msgType.SKEY_HANDSHAKE_2) {
        if (handshakeTimeout) {
            clearTimeout(handshakeTimeout);
            handshakeTimeout = null;
        }
        console.log('received session key handshake2!');
        if (helperOptions.entityClientState != entityClientCommState.HANDSHAKE_1_SENT) {
            eventHandlers.onError('Comm init failed: wrong sequence of handshake, disconnecting...');
            helperEventHandlers.onEnd();
            return;
        }

        var buf = common.symmetricDecryptAuthenticate(helperOptions.payload, options.sessionKey, options.sessionCryptoSpec);
        var ret = common.parseHandshake(buf);
        console.log('client ret: ' + util.inspect(ret));

        if (helperOptions.myNonce.equals(ret.replyNonce)) {
            console.log('server authenticated/authorized by solving nonce!');
        }
        else {
            eventHandlers.onError('Comm init failed: server NOT verified, nonce NOT matched, disconnecting...');
            helperEventHandlers.onEnd();
            return;
        }

        var theirNonce = ret.nonce;
        var handshake3 = {replyNonce: theirNonce};

        var clientECDH;
        if (options.sessionCryptoSpec.diffieHellman) {
            console.log('Using Diffie-Hellman algorithm: ' + options.sessionCryptoSpec.diffieHellman);
            clientECDH = crypto.createECDH(options.sessionCryptoSpec.diffieHellman);
            handshake3.dhParam = clientECDH.generateKeys();
        }

        buf = common.serializeHandshake(handshake3);
        var enc = common.symmetricEncryptAuthenticate(buf, options.sessionKey, options.sessionCryptoSpec);

        var msg = {
            msgType: msgType.SKEY_HANDSHAKE_3,
            payload: enc
        };
        helperEventHandlers.onWrite(common.serializeIoTSP(msg));

        if (options.sessionCryptoSpec.diffieHellman) {
            var newSessionKeyVal = clientECDH.computeSecret(ret.dhParam);
            console.log('new session key value (cipher + mac): ');
            console.log(newSessionKeyVal);
            helperEventHandlers.onConnection(newSessionKeyVal);
            return;
        }
        else {
            helperEventHandlers.onConnection(null);
            return;
        }
    }        
    else if (helperOptions.msgType == msgType.SECURE_COMM_MSG) {
        console.log('received secure communication message!');
        if (helperOptions.entityClientState == entityClientCommState.IN_COMM) {
            var ret = helperOptions.iotSecureSocket.receive(helperOptions.payload);
            if (!ret.success) {
                eventHandlers.onError(ret.error);
                return;
            }
            eventHandlers.onData(ret.data);
            return;
        }
        else {
            options.onError('Error: it is not in IN_COMM state, disconnecting...');
            helperEventHandlers.onEnd();
            return;
        }
    }
    eventHandlers.onError('Error: unexpected message from server, disconnecting...');
    helperEventHandlers.onEnd();
    return;
}

exports.initializeSecureCommunicationOnTCP = function(options, eventHandlers) {
    if (options.sessionKey == null) {
        eventHandlers.onError('Comm init failed: No available key');
        return;
    }

    var entityClientState = entityClientCommState.IDLE;

    // per connection information
    console.log('chosen commSessionKey: ');
    console.log(options.sessionKey);
    console.log('options');
    console.log(options);
    var myNonce;
    var iotSecureSocket = null;

    var entityClientSocket;

    function onEnd() {
        if (entityClientSocket != null) {
            entityClientSocket.end();
            entityClientSocket = null;
        }
    }
    function onWrite(buf) {
        entityClientSocket.write(buf);
    }
    function onConnection(newSessionKeyVal) {           
        var entityClientSocketEventHandlers = {
            onWrite: onWrite,
            onEnd: onEnd
        };
        if (newSessionKeyVal != null) {     // only when DH is used   
            options.sessionKey = common.updateSymmetricKeyWithKeyFromDH(options.sessionKey, newSessionKeyVal);
            console.log('new session key: ' + util.inspect(options.sessionKey));
        }
        iotSecureSocket = new IoTSecureSocket(entityClientSocketEventHandlers, options.sessionKey, options.sessionCryptoSpec);
        eventHandlers.onConnection(iotSecureSocket);

        console.log('switching to IN_COMM');
        entityClientState = entityClientCommState.IN_COMM;
    }
    var helperEventHandlers = {
        onWrite: onWrite,
        onEnd: onEnd,
        onConnection: onConnection
    }

    entityClientSocket = net.connect({host:options.serverHost, port: options.serverPort},
        function() {
            try {
                var ret = secureClientHelper(null, helperEventHandlers, options, eventHandlers);
                myNonce = ret.myNonce;
                entityClientState = entityClientCommState.HANDSHAKE_1_SENT;
            }
            catch (err) {
                eventHandlers.onError('Exception occurred: ' + err);
            }
    });

    entityClientSocket.on('end', function() {
        if (entityClientState == entityClientCommState.IN_COMM) {
            eventHandlers.onClose();
            return;
        }
        eventHandlers.onError('Comm init failed: disconnected from server during communication initialization.' +
            options.serverHost + ':' + options.serverport);
        entityClientState = entityClientCommState.IDLE;
    });
    entityClientSocket.on('error', function(message) {
        if (entityClientState == entityClientCommState.IN_COMM) {
            eventHandlers.onError(message);
            return;
        }
        eventHandlers.onError('Comm init failed: Error in comm init - details: ' + message);
        entityClientSocket.end();
        return;
    });

    var expectingMoreData = false;
    var obj;

    entityClientSocket.on('data', function(data) {
        if (!expectingMoreData) {
            obj = common.parseIoTSP(data);
            if (obj.payload.length < obj.payloadLen) {
                expectingMoreData = true;
                console.log('more data will come. current: ' + obj.payload.length
                    + ' expected: ' + obj.payloadLen);
            }
        }
        else {
            obj.payload = Buffer.concat([obj.payload, data]);
            if (obj.payload.length ==  obj.payloadLen) {
                expectingMoreData = false;
            }
            else {
                console.log('more data will come. current: ' + obj.payload.length
                    + ' expected: ' + obj.payloadLen);
            }
        }
        if (expectingMoreData) {
            // do not process the packet yet
            return;
        }
        var helperOptions = {
            msgType: obj.msgType,
            payload: obj.payload,
            myNonce: myNonce,
            entityClientState: entityClientState,
            iotSecureSocket: iotSecureSocket
        };
        try {
            secureClientHelper(helperOptions, helperEventHandlers, options, eventHandlers);
        }
        catch (err) {
            eventHandlers.onError('Exception occurred: ' + err);
        }
    });
}

exports.initializeSecureCommunicationOnUDP = function(options, eventHandlers) {
    var udpClientSocket = dgram.createSocket('udp4');
    var entityClientState = entityClientCommState.IDLE;
    var myNonce;
    var iotSecureSocket = null;

    function onEnd() {
        udpClientSocket.close();
    }
    function onWrite(buf) {
        udpClientSocket.send(buf, 0, buf.length, options.serverPort, options.serverHost, (err) => {
            if (err) {
                console.error('udp client error: ' + err);
            }
            //socket.close();
        });
    }
    function onActiveEnd() {
        console.log('in onActiveEnd');
        var buf = common.serializeIoTSP({
            msgType: msgType.FIN_SECURE_COMM,
            payload: Buffer.alloc(0)
        });
        try {
            udpClientSocket.send(buf, 0, buf.length, options.serverPort, options.serverHost, (err) => {
                udpClientSocket.close();
                udpClientSocket = null;
            });
        }
        catch(err) {
            console.error('udp active end err: ' + err);
        }
        //udpClientSocket.close();
    }
    function onConnection(newSessionKeyVal) {
        var entityClientSocketEventHandlers = {
            onWrite: onWrite,
            onEnd: onActiveEnd
        };
        if (newSessionKeyVal != null) {     // only when DH is used     
            options.sessionKey = common.updateSymmetricKeyWithKeyFromDH(options.sessionKey, newSessionKeyVal);
            console.log('new session key: ' + util.inspect(options.sessionKey));
        }
        iotSecureSocket = new IoTSecureSocket(entityClientSocketEventHandlers, options.sessionKey, options.sessionCryptoSpec);
        eventHandlers.onConnection(iotSecureSocket);

        console.log('switching to IN_COMM');
        entityClientState = entityClientCommState.IN_COMM;
    }
    var helperEventHandlers = {
        onEnd: onEnd,
        onWrite: onWrite,
        onConnection: onConnection
    };

    udpClientSocket.on('listening', () => {
        var address = udpClientSocket.address();
        console.log('client listening ' + address.address + ':' + address.port);
    });

    udpClientSocket.on('message', (data, rinfo) => {
        // if it's auth hello?

        console.log('some message received?');
        console.log('Received %d bytes from %s:%d\n',
            data.length, rinfo.address, rinfo.port);

        var obj = common.parseIoTSP(data);
        if (obj.payload.length != obj.payloadLen) {
            console.error('wrong payload length: ' + obj.payload.length + ' should be: ' + obj.payloadLen);
            return;
        }
        var helperOptions = {
            msgType: obj.msgType,
            payload: obj.payload,
            myNonce: myNonce,
            entityClientState: entityClientState,
            iotSecureSocket: iotSecureSocket
        };
        try {
            secureClientHelper(helperOptions, helperEventHandlers, options, eventHandlers);
        }
        catch (err) {
            eventHandlers.onError('Exception occurred: ' + err);
        }
    });

    udpClientSocket.bind();

    try {
        var ret = secureClientHelper(null, helperEventHandlers, options, eventHandlers);
        myNonce = ret.myNonce;
        entityClientState = entityClientCommState.HANDSHAKE_1_SENT;
    }
    catch (err) {
        eventHandlers.onError('Exception occurred: ' + err);
    }
}


