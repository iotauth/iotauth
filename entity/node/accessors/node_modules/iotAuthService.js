/*
 * Copyright (c) 2016, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * IOTAUTH_COPYRIGHT_VERSION_1
 */

/**
 * Helper module for accessing IoT Auth services, including session key request and responses
 * @author Hokeun Kim
 */

"use strict";

var net = require('net');
var dgram = require('dgram');
var crypto = require('crypto');
var util = require('util');
var pem = require('pem');
var fs = require('fs');

// local modules
var common = require('./common');
var msgType = common.msgType;

// local variables
var AUTH_NONCE_SIZE = 8;        // auth nonce size
var DIST_KEY_EXPIRATION_TIME_SIZE = 6;
var SESSION_KEY_EXPIRATION_TIME_SIZE = 6;
var REL_VALIDITY_SIZE = 6;

// generate auth hello nonce
var generateAuthNonce = function() {
    return crypto.randomBytes(AUTH_NONCE_SIZE);
};

/*
    AuthHello Format
    {
        authId: /UInt32BE/,    // identifier of auth (when auths are replicated)
        nonce: /Buffer/
    }
*/
var serializeAuthHello = function(obj) {
    if (obj.authId == undefined || obj.nonce == undefined) {
        console.log('Error: AuthHello authId or nonce is missing.');
        return;
    }
    var buf = Buffer.alloc(4 + AUTH_NONCE_SIZE);
    buf.writeUInt32BE(obj.authId, 0);
    obj.nonce.copy(buf, 4);
    return buf;
};
var parseAuthHello = function(buf) {
    var authId = buf.readUInt32BE(0);
    var nonce = buf.slice(4, 4 + AUTH_NONCE_SIZE);
    return {authId: authId, nonce: nonce};
};

/*
    AuthAlert Format
    {
        alertCode: /Byte/
    }
*/
var parseAuthAlert = function(buf) {
    var alertCode = buf.readUInt8(0);
    return {alertCode: alertCode};
};

/*
    SessionKeyReq Format
    {
        nonce: /Buffer/, (AUTH_NONCE_SIZE)
        replyNonce:    /Buffer/, (AUTH_NONCE_SIZE)
        numKeys: /UInt32BE/,
        sender: /string/, (senderLen UInt8)
        purpose: JSON,
        dhParam: /Buffer/ (optional, Diffie-Hellman parameter)
    }
*/
var serializeSessionKeyReq = function(obj) {
    if (obj.nonce == undefined || obj.replyNonce == undefined || obj.sender == undefined
        || obj.purpose == undefined || obj.numKeys == undefined) {
        console.log('Error: SessionKeyReq nonce or replyNonce '
            + 'or purpose or numKeys is missing.');
        return;
    }
    var buf = Buffer.alloc(AUTH_NONCE_SIZE * 2 + 4);
    obj.nonce.copy(buf, 0);
    obj.replyNonce.copy(buf, AUTH_NONCE_SIZE);
    buf.writeUInt32BE(obj.numKeys, AUTH_NONCE_SIZE * 2);

    var senderBuf = common.serializeStringParam(obj.sender);
    var purposeBuf = common.serializeStringParam(JSON.stringify(obj.purpose));

    var ret = Buffer.concat([buf, senderBuf, purposeBuf]);
    if (obj.dhParam) {
        ret = Buffer.concat([ret, obj.dhParam]);
    }
    return ret;
};

/*
    DistributionKey Format
    {
        absValidity: /UIntBE, DIST_KEY_EXPIRATION_TIME_SIZE Bytes, Date() format/, // for absolute validity period
        cipherKeySize: /UInt8BE/,
        cipherKeyVal: /Buffer/,
        macKeySize: /UInt8BE/,
        macKeyVal: /Buffer/
    }
*/
var parseDistributionKey = function(buf) {
    var absValidity = new Date(common.readVariableUIntBE(buf, 0, DIST_KEY_EXPIRATION_TIME_SIZE));
    var curIndex = DIST_KEY_EXPIRATION_TIME_SIZE;
    var cipherKeySize = buf.readUInt8(curIndex);
    curIndex += 1;
    var cipherKeyVal = buf.slice(curIndex, curIndex + cipherKeySize);
    curIndex += cipherKeySize;
    var macKeySize = buf.readUInt8(curIndex);
    curIndex += 1;
    var macKeyVal = buf.slice(curIndex, curIndex + macKeySize);
    return {
        cipherKeyVal: cipherKeyVal,
        macKeyVal: macKeyVal,
        absValidity: absValidity
    };
};

/*
    DistributionDiffieHellmanParameter Format
    {
        absValidity: /UIntBE, DIST_KEY_EXPIRATION_TIME_SIZE Bytes, Date() format/, // for absolute validity period
        parameterLength: /VarLenInt/
        parameter: /Buffer/
    }
*/
var parseDistributionDiffieHellmanParameter = function(buf) {
    var curIndex = 0;
    var absValidity = new Date(common.readVariableUIntBE(buf, curIndex, DIST_KEY_EXPIRATION_TIME_SIZE));
    curIndex += DIST_KEY_EXPIRATION_TIME_SIZE;
    var ret = common.varLenIntToNum(buf, curIndex);
    curIndex += ret.bufLen;
    return {
        absValidity: absValidity,
        parameter: buf.slice(curIndex)
    }
}
/*
    SessionKey Format
    {
        id: /UIntBE, SESSION_KEY_ID_SIZE Bytes/,
        absValidity: /UIntBE, SESSION_KEY_EXPIRATION_TIME_SIZE Bytes, Date() format/, // for absolute validity period
        relValidity: /UIntBE, REL_VALIDITY_SIZE Bytes, integer in millisecons/, // for relative validity period
        val: /Buffer/
    }
*/
function parseSessionKey(buf) {
    var keyId = common.readVariableUIntBE(buf, 0, common.SESSION_KEY_ID_SIZE);
    var curIndex = common.SESSION_KEY_ID_SIZE;

    var absValidity = new Date(common.readVariableUIntBE(buf, curIndex, SESSION_KEY_EXPIRATION_TIME_SIZE));
    curIndex += SESSION_KEY_EXPIRATION_TIME_SIZE;
    var relValidity = common.readVariableUIntBE(buf, curIndex, REL_VALIDITY_SIZE);
    curIndex += REL_VALIDITY_SIZE;

    var cipherKeySize = buf.readUInt8(curIndex);
    curIndex += 1;
    var cipherKeyVal = buf.slice(curIndex, curIndex + cipherKeySize);
    curIndex += cipherKeySize;
    var macKeySize = buf.readUInt8(curIndex);
    curIndex += 1;
    var macKeyVal = buf.slice(curIndex, curIndex + macKeySize);
    curIndex += macKeySize;

    var sessionKey = {
        id: keyId,
        cipherKeyVal: cipherKeyVal,
        macKeyVal: macKeyVal,
        absValidity: absValidity,
        relValidity: relValidity
    };
    return {sessionKey: sessionKey, totalLen: curIndex};
};

/*
    SessionKeyReq (encrypted with Distribution Key) Format
    {
        sender: /string/, (senderLen UInt8) should be plain text so that Auth can find distribution key
        enBuf: /Buffer/ SessionKeyReq (nonce included) encrypted with distribution key
    }
*/
var serializeSessionKeyReqWithDistributionKey = function(senderName,
    sessionKeyReq, distributionKey, distributionCryptoSpec) {
    var sessionKeyReqBuf = serializeSessionKeyReq(sessionKeyReq);
    var encBuf = common.symmetricEncryptAuthenticate(sessionKeyReqBuf, distributionKey, distributionCryptoSpec);

    // TEST: generating error in encrypted data
    //encBuf.writeUInt8(12, encBuf.length - 12);

    var senderBuf = Buffer.from(senderName);
    var lengthBuf = Buffer.alloc(1);
    lengthBuf.writeUInt8(senderBuf.length);
    return Buffer.concat([lengthBuf, senderBuf, encBuf]);
};

/*
    SessionKeyResp Format
    {
        replyNonce:    /Buffer/,
        cryptoSpec:    /JSON/ {cipher: 'AES-128-CBC', hash: 'SHA256'} stringified, 
        sessionKeyList: /UInt32BE for length and List of SessionKey's/
        // TODO: who you're talking to? if req included keyId=?
    }
*/
var parseSessionKeyResp = function(buf) {
    var replyNonce = buf.slice(0, AUTH_NONCE_SIZE);
    var bufIdx = AUTH_NONCE_SIZE;

    var ret = common.parseStringParam(buf, bufIdx);
    var cryptoSpec = JSON.parse(ret.str);
    bufIdx += ret.len;

    var sessionKeyListLength = buf.readUInt32BE(bufIdx);
    bufIdx += 4;

    var sessionKeyList = [];
    for (var i = 0; i < sessionKeyListLength; i++) {
        var ret = parseSessionKey(buf.slice(bufIdx));
        var sessionKey = ret.sessionKey;
        sessionKeyList.push(sessionKey);
        bufIdx += ret.totalLen;
    }
    return {replyNonce: replyNonce, cryptoSpec: cryptoSpec, sessionKeyList: sessionKeyList};
};

/*
    MigrationReq Format
    {
        nonce: /Buffer/, (AUTH_NONCE_SIZE)
        replyNonce:    /Buffer/, (AUTH_NONCE_SIZE)
        sender: /string/ (senderLen UInt8)
    }
*/
var serializeMigrationReq = function(obj) {
    if (obj.nonce == undefined || obj.replyNonce == undefined || obj.sender == undefined) {
        console.log('Error: MigrationReq nonce or replyNonce '
            + 'or sender is missing.');
        return;
    }
    var buf = Buffer.alloc(AUTH_NONCE_SIZE * 2);
    obj.nonce.copy(buf, 0);
    obj.replyNonce.copy(buf, AUTH_NONCE_SIZE);

    var senderBuf = common.serializeStringParam(obj.sender);

    var ret = Buffer.concat([buf, senderBuf]);
    return ret;
}
/*
    MigrationResp Format
    {
        authId: /UInt32/,
        replyNonce: /Nonce/,
        authToken: (authCert: /String/, or encryptedNewDistributionKey: /Buffer/)
    }
 */
var parseMigrationResp = function(buf) {
    var bufIdx = 0;
    var authId = buf.readUInt32BE(bufIdx);
    bufIdx += 4;
    var replyNonce = buf.slice(bufIdx, bufIdx + AUTH_NONCE_SIZE);
    bufIdx += AUTH_NONCE_SIZE;

    var authToken = buf.slice(bufIdx);
    return {authId: authId, replyNonce: replyNonce, authToken: authToken};
}

///////////////////////////////////////////////////////////////////
////           Functions for accessing Auth service            ////
/*
helperOptions = {
    msgType,
    payload,
    myNonce,
    myECDH // object for ECDH: Elliptic Curve Diffie-Hellman (optionally created inside sendSessionKeyReqHelper)
}
*/
/*
helperEventHandlers = {
    onWrite,
    onEnd,
    onError
}
*/
/*
ret = {
    success,
    myNonce,
    myECDH
}
*/
var authHelloTimeout = null;
var authConnectionTimeout = null;
function sendSessionKeyReqHelper(helperOptions, helperEventHandlers, options, sessionKeyRespHandler, callbackParams) {
    function authConnectionTimeoutHandler() {
        authConnectionTimeout = null;
        helperEventHandlers.onError('Connection with Auth timed out...');
    }
    if (helperOptions.msgType == msgType.AUTH_HELLO) {
        if (authHelloTimeout) {
            clearTimeout(authHelloTimeout);
            authHelloTimeout = null;
        }
        console.log('received auth hello!');
        var obj = parseAuthHello(helperOptions.payload);
        console.log(obj);
        helperOptions.myNonce = generateAuthNonce();

        var sessionKeyReq = {
            nonce: helperOptions.myNonce,
            replyNonce: obj.nonce,
            numKeys: options.numKeysPerRequest,
            sender: options.entityName,
            purpose: options.purpose
        };

        var msg;
        if (options.distributionKey == null || options.distributionKey.absValidity < new Date()) {
            if (options.distributionKey != null) {
                console.log('current distribution key expired, '
                    + 'requesting new distribution key as well...');
            }
            if (options.publicKeyCryptoSpec.diffieHellman) {
                console.log('Diffie-Hellman enabled for distribution key, creating DH parameters...');
                helperOptions.myECDH = crypto.createECDH(options.publicKeyCryptoSpec.diffieHellman);
                sessionKeyReq.dhParam = helperOptions.myECDH.generateKeys();
            }
            var sessionKeyReqBuf = serializeSessionKeyReq(sessionKeyReq);
            msg = {
                msgType: msgType.SESSION_KEY_REQ_IN_PUB_ENC,
                payload: common.publicEncryptAndSign(
                    sessionKeyReqBuf, options.authPublicKey, options.entityPrivateKey, options.publicKeyCryptoSpec)
            };
            // TEST: generating error in signature
            //msg.payload.writeUInt8(12, msg.payload.length - 12);
        }
        else {
            msg = {
                msgType: msgType.SESSION_KEY_REQ,
                payload: serializeSessionKeyReqWithDistributionKey(options.entityName,
                    sessionKeyReq, options.distributionKey, options.distributionCryptoSpec)
            };
        }
        
        var buf = common.serializeIoTSP(msg);
        helperEventHandlers.onWrite(buf);
        if (options.connectionTimeout == null) {
            throw 'Timeout for Auth connection is not set!';
        }
        authConnectionTimeout = setTimeout(authConnectionTimeoutHandler, options.connectionTimeout);
    }
    else if (helperOptions.msgType == msgType.SESSION_KEY_RESP_WITH_DIST_KEY) {
        if (authConnectionTimeout) {
            clearTimeout(authConnectionTimeout);
            authConnectionTimeout = null;
        }
        console.log('received session key response with distribution key attached!');

        var distributionKeyBuf = helperOptions.payload.slice(0, common.getPublicEncryptedAndSignedMessageSize(options.publicKeyCryptoSpec));
        var sessionKeyBuf = helperOptions.payload.slice(common.getPublicEncryptedAndSignedMessageSize(options.publicKeyCryptoSpec));

        var ret = common.verifySignedData(distributionKeyBuf, options.authPublicKey, options.publicKeyCryptoSpec);
        if (!ret.verified) {
            return {success: false, error: 'auth signature NOT verified'};
        }
        console.log('auth signature verified');
        var decBuf = common.privateDecrypt(ret.buf, options.entityPrivateKey, options.publicKeyCryptoSpec);

        var receivedOrDerivedDistKey;
        if (options.publicKeyCryptoSpec.diffieHellman) {
            console.log('Diffie-Hellman enabled! Getting DH parameter from Auth...');
            // if so, receivedDistKey.cipherKeyVal should be a Diffie-Hellman parameter rather than a distribution key
            var authDHParam = parseDistributionDiffieHellmanParameter(decBuf);
            var dhSecret = helperOptions.myECDH.computeSecret(authDHParam.parameter);
            var cipherKeySize = common.getCryptoKeySize(options.distributionCryptoSpec.cipher);
            var macKeySize = common.getCryptoKeySize(options.distributionCryptoSpec.mac);
            receivedOrDerivedDistKey = {
                absValidity: authDHParam.absValidity,
                cipherKeyVal: dhSecret.slice(0, cipherKeySize),
                macKeyVal: dhSecret.slice(cipherKeySize, cipherKeySize + macKeySize)
            }
            console.log('New ephemeral distribution key successfully generated from DH parameter of Auth!');
        }
        else {
            receivedOrDerivedDistKey = parseDistributionKey(decBuf);
        }

        decBuf = common.symmetricDecryptAuthenticate(sessionKeyBuf, receivedOrDerivedDistKey, options.distributionCryptoSpec);

        var sessionKeyResp = parseSessionKeyResp(decBuf);
        console.log('replyNonce in sessionKeyResp: ' + util.inspect(sessionKeyResp.replyNonce));
        if (!helperOptions.myNonce.equals(sessionKeyResp.replyNonce)) {
            return {success: false, error: 'auth nonce NOT verified'};
        }
        console.log('auth nonce verified');

        sessionKeyRespHandler(sessionKeyResp.sessionKeyList, receivedOrDerivedDistKey, callbackParams);
        helperEventHandlers.onEnd();
    }
    else if (helperOptions.msgType == msgType.SESSION_KEY_RESP) {
        if (authConnectionTimeout) {
            clearTimeout(authConnectionTimeout);
            authConnectionTimeout = null;
        }
        console.log('received session key response encrypted with distribution key');

        var decBuf = common.symmetricDecryptAuthenticate(helperOptions.payload, options.distributionKey, options.distributionCryptoSpec);

        var sessionKeyResp = parseSessionKeyResp(decBuf);
        console.log('replyNonce in sessionKeyResp: ' + util.inspect(sessionKeyResp.replyNonce));
        if (!helperOptions.myNonce.equals(sessionKeyResp.replyNonce)) {
            return {success: false, error: 'auth nonce NOT verified'};
        }
        console.log('auth nonce verified');

        sessionKeyRespHandler(sessionKeyResp.sessionKeyList, null, callbackParams);
        helperEventHandlers.onEnd();
    }
    else if (helperOptions.msgType == msgType.AUTH_ALERT) {
        if (authConnectionTimeout) {
            clearTimeout(authConnectionTimeout);
            authConnectionTimeout = null;
        }
        console.log('received an Auth alert!');
        var authAlert = parseAuthAlert(helperOptions.payload);
        return {success: false, error: 'received an Auth alert! code: ' + authAlert.alertCode};
    }
    else {
        return {success: false, error: 'unrecognized Auth message!'};
    }
    return {success: true, myNonce: helperOptions.myNonce, myECDH: helperOptions.myECDH};
};

/*
eventHandlers = {
    onError
}
*/
exports.sendSessionKeyReqViaTCP = function(options, sessionKeyRespHandler, eventHandlers, callbackParams) {
    var myNonce;
    var myECDH;
    var expectingMoreData = false;
    var obj;
    var requestSucceeded = false;
    var authClientSocket = net.connect({host: options.authHost,port: options.authPort}, 
        function() {
            console.log('connected to auth! from local port ' + authClientSocket.localPort);
    });
    function onEnd() {
        authClientSocket.end();
    }
    function onError(error) {
        authClientSocket.end();
        eventHandlers.onError(error);
    }
    function onWrite(buf) {
        authClientSocket.write(buf);
    }
    function authHelloTimeoutHandler() {
        onError('Auth hello timedout ...');
    }
    authHelloTimeout = setTimeout(authHelloTimeoutHandler, options.connectionTimeout);
    
    var helperEventHandlers = {
        onEnd: onEnd,
        onWrite: onWrite,
        onError: onError
    };
    authClientSocket.on('data', function(data) {
        if (!expectingMoreData) {
            obj = common.parseIoTSP(data);
            if (obj.payload.length < obj.payloadLen) {
                expectingMoreData = true;
                console.log('more data will come. current: ' + obj.payload.length
                    + ' expected: ' + obj.payloadLen);
            }
        }
        else {
            obj.payload = Buffer.concat([obj.payload, data]);
            if (obj.payload.length ==  obj.payloadLen) {
                expectingMoreData = false;
            }
            else {
                console.log('more data will come. current: ' + obj.payload.length
                    + ' expected: ' + obj.payloadLen);
            }
        }

        // Test code
        //sleep.sleep(1);

        if (expectingMoreData) {
            // do not process the packet yet
            return;
        }
        else {
            var helperOptions = {
                msgType: obj.msgType,
                payload: obj.payload,
                myNonce: myNonce,
                myECDH: myECDH
            };
            var ret = sendSessionKeyReqHelper(helperOptions, helperEventHandlers,
                options, sessionKeyRespHandler, callbackParams);
            if (!ret.success) {
                authClientSocket.end();
                eventHandlers.onError(ret.error);
                return;
            }
            requestSucceeded = true;
            myNonce = ret.myNonce;
            myECDH = ret.myECDH;
        }
    });
    authClientSocket.on('error', function(error) {
        eventHandlers.onError('Error occurred in session key request: ' + error);
    });
    authClientSocket.on('end', function() {
        if (!requestSucceeded) {
            eventHandlers.onError('Disconnected from auth before getting session key response');
        }
        else {
            console.log('disconnected from auth');
        }
    });
};

/*
eventHandlers = {
    onError
}
*/
exports.sendSessionKeyReqViaUDP = function(options, sessionKeyRespHandler, eventHandlers, callbackParams) {
    var authUdpClientSocket = dgram.createSocket('udp4');

    var requestSucceeded = false;
    function onEnd() {
        authUdpClientSocket.close();
    }
    function onError(error) {
        try {
            authUdpClientSocket.close();
        }
        catch (err) {
            error += ' & ' + err;
        }
        eventHandlers.onError(error);
    }
    function onWrite(buf) {
        authUdpClientSocket.send(buf, 0, buf.length, options.authPort, options.authHost, (err) => {
            //socket.close();
        });
    }
    var helperEventHandlers = {
        onEnd: onEnd,
        onWrite: onWrite,
        onError: onError
    };

    authUdpClientSocket.on('listening', () => {
      var address = authUdpClientSocket.address();
      console.log('entity listening to Auth on ' + address.address + ':' + address.port);
    });

    var myNonce;
    var myECDH;
    authUdpClientSocket.on('message', (data, rinfo) => {
        // if it's auth hello?

        console.log('some message received?');
        console.log('Received %d bytes from %s:%d\n',
            data.length, rinfo.address, rinfo.port);

        var obj = common.parseIoTSP(data);
        if (obj.payload.length != obj.payloadLen) {
            authUdpClientSocket.end();
            eventHandlers.onError('Error occurred in session key request: ' + 'wrong payload length: ' + obj.payload.length + ' should be: ' + obj.payloadLen);
            return;
        }

        var helperOptions = {
            msgType: obj.msgType,
            payload: obj.payload,
            myNonce: myNonce,
            myECDH: myECDH
        };
        var ret = sendSessionKeyReqHelper(helperOptions, helperEventHandlers,
            options, sessionKeyRespHandler, callbackParams);
        if (!ret.success) {
            authUdpClientSocket.end();
            eventHandlers.onError(ret.error);
            return;
        }
        myNonce = ret.myNonce;
        myECDH = ret.myECDH;
    });

    authUdpClientSocket.bind();

    var entityHello = Buffer.alloc(1);
    entityHello.writeUInt8(msgType.ENTITY_HELLO);

    authUdpClientSocket.send(entityHello, 0, entityHello.length, options.authPort, options.authHost, (err) => {
        //socket.close();
    });
    if (options.connectionTimeout == null) {
        throw 'timeout for Auth hello is not set!';
    }
    function authHelloTimeoutHandler() {
        onError('Auth hello timedout ...');
    }
    authHelloTimeout = setTimeout(authHelloTimeoutHandler, options.connectionTimeout);
};

/*
helperOptions = {
    msgType,
    payload,
    myNonce
}
*/
function sendMigrationReqHelper(helperOptions, helperEventHandlers, options, migrationRespHandler) {
    function authConnectionTimeoutHandler() {
        authConnectionTimeout = null;
        helperEventHandlers.onError('Connection with Auth timed out...');
    }
    if (helperOptions.msgType == msgType.AUTH_HELLO) {
        if (authHelloTimeout) {
            clearTimeout(authHelloTimeout);
            authHelloTimeout = null;
        }
        console.log('received auth hello!');
        var obj = parseAuthHello(helperOptions.payload);
        console.log(obj);
        helperOptions.myNonce = generateAuthNonce();

        var migrationReq = {
            nonce: helperOptions.myNonce,
            replyNonce: obj.nonce,
            sender: options.entityName
        };

        var migrationReqBuf = serializeMigrationReq(migrationReq);
        var msg;
        if (options.usePermanentDistKey == true) {
            msg = {
                msgType: msgType.MIGRATION_REQ_WITH_MAC,
                payload: common.symmetricAuthenticateAttach(migrationReqBuf, options.permanentDistKey, options.distributionCryptoSpec)
            };
        }
        else {
            msg = {
                msgType: msgType.MIGRATION_REQ_WITH_SIGN,
                payload: common.signAndAttach(migrationReqBuf, options.entityPrivateKey, options.publicKeyCryptoSpec)
            };
        }
        /*
        if (options.distributionKey == null || options.distributionKey.absValidity < new Date()) {
            if (options.distributionKey != null) {
                console.log('current distribution key expired, '
                    + 'requesting new distribution key as well...');
            }
            if (options.publicKeyCryptoSpec.diffieHellman) {
                console.log('Diffie-Hellman enabled for distribution key, creating DH parameters...');
                helperOptions.myECDH = crypto.createECDH(options.publicKeyCryptoSpec.diffieHellman);
                sessionKeyReq.dhParam = helperOptions.myECDH.generateKeys();
            }
            var sessionKeyReqBuf = serializeSessionKeyReq(sessionKeyReq);
            msg = {
                msgType: msgType.SESSION_KEY_REQ_IN_PUB_ENC,
                payload: common.publicEncryptAndSign(
                    sessionKeyReqBuf, options.authPublicKey, options.entityPrivateKey, options.publicKeyCryptoSpec)
            };
            // TEST: generating error in signature
            //msg.payload.writeUInt8(12, msg.payload.length - 12);
        }
        else {
            msg = {
                msgType: msgType.SESSION_KEY_REQ,
                payload: serializeSessionKeyReqWithDistributionKey(options.entityName,
                    sessionKeyReq, options.distributionKey, options.distributionCryptoSpec)
            };
        }
        */
        
        var buf = common.serializeIoTSP(msg);
        helperEventHandlers.onWrite(buf);
        if (options.connectionTimeout == null) {
            throw 'Timeout for Auth connection is not set!';
        }
        authConnectionTimeout = setTimeout(authConnectionTimeoutHandler, options.connectionTimeout);
    }
    else if (helperOptions.msgType == msgType.MIGRATION_RESP_WITH_SIGN) {
        if (authConnectionTimeout) {
            clearTimeout(authConnectionTimeout);
            authConnectionTimeout = null;
        }
        console.log('received migration response with signature!');
        var signedData = common.parseSignedData(helperOptions.payload, options.publicKeyCryptoSpec);
        var migrationResp = parseMigrationResp(signedData.data);
        //console.log(util.inspect(migrationResp));

        //var certificate = crypto.Certificate();

        var ret = common.parseStringParam(migrationResp.authToken, 0);
        var authCert = ret.str;
        var cert = x509.parseCert(authCert);
        console.log(util.inspect(cert));
        //console.log(options.currentAuthPublicKey.toString());
        //console.log(x509.parseCert(options.currentAuthPublicKey.toString()));

        // verify certificate
        var caCert = fs.readFileSync('../../../auth/credentials/ca/CACert.pem');
        var trustedCertificateList = [];
        for (var i = 0; i < options.trustedAuthPublicKeyList.length; i++) {
            trustedCertificateList.push(options.trustedAuthPublicKeyList.toString());
        }
        trustedCertificateList.push(caCert.toString());
        pem.verifySigningChain(authCert.toString(),
            trustedCertificateList,
            // this callback brings about the verification result
            function(err, result) {
                console.log(err);
                console.log(result);
            if (result != true) {
                helperEventHandlers.onError('Certificate of new Auth is NOT verified!');
                return;
            }
            console.log('Certificate of new Auth is verified!');
            var authCertSubject = x509.getSubject(authCert);
            if (authCertSubject.organizationalUnitName != 'Auth' + migrationResp.authId) {
                helperEventHandlers.onError('Subject information does NOT match Auth ID!');
                return;
            }
            console.log('Subject information matches Auth ID!');
            // now use new auth's certificate to verify signature of migration response
            var ret = common.verifySignedData(helperOptions.payload, authCert, options.publicKeyCryptoSpec);
            //console.log(util.inspect(ret));
            if (ret.verified != true) {
                helperEventHandlers.onError('Signature of new Auth is NOT verified!');
                return;
            }
            console.log('Signature of new Auth is verified.')

            // now verify nonce
            if (!helperOptions.myNonce.equals(migrationResp.replyNonce)) {
                helperEventHandlers.onError('Auth nonce is NOT verified');
                return;
            }
            console.log('Auth nonce is verified');
            migrationRespHandler(migrationResp.authId, authCert);
            // return and let them update authId and auth certificate
        });
    }
    else if (helperOptions.msgType == msgType.MIGRATION_RESP_WITH_MAC) {
        if (authConnectionTimeout) {
            clearTimeout(authConnectionTimeout);
            authConnectionTimeout = null;
        }
        console.log('received migration response! with MAC');

        // check mac if there's a mac error, it will raise an exception
        var data = common.symmetricVerifyExtract(helperOptions.payload, options.permanentDistKey, options.distributionCryptoSpec);
        console.log('MAC of new Auth is verified! New Auth has a valid MAC key!');

        var migrationResp = parseMigrationResp(data);

        // now verify nonce
        if (!helperOptions.myNonce.equals(migrationResp.replyNonce)) {
            helperEventHandlers.onError('Auth nonce is NOT verified');
            return;
        }
        console.log('Auth nonce is verified');
        var encryptedNewDistributionKey = migrationResp.authToken;
        var newDistributionKeyBuf = common.symmetricDecryptAuthenticate(encryptedNewDistributionKey, options.permanentDistKey, options.distributionCryptoSpec);
        var newDistributionKey = parseDistributionKey(newDistributionKeyBuf);
        console.log(util.inspect(newDistributionKey));
        migrationRespHandler(migrationResp.authId, newDistributionKey);
    }
    else if (helperOptions.msgType == msgType.AUTH_ALERT) {
        if (authConnectionTimeout) {
            clearTimeout(authConnectionTimeout);
            authConnectionTimeout = null;
        }
        console.log('received an Auth alert!');
        var authAlert = parseAuthAlert(helperOptions.payload);
        return {success: false, error: 'received an Auth alert! code: ' + authAlert.alertCode};
    }
    else {
        return {success: false, error: 'unrecognized Auth message!'};
    }

    return {success: true, myNonce: helperOptions.myNonce};
}

exports.sendMigrationReqViaTCP = function(options, migrationRespHandler, eventHandlers) {
    //console.log('In iotAuthService.js sendMigrationReqViaTCP: ' + util.inspect(options));
    console.log('In iotAuthService.js sendMigrationReqViaTCP: ');

    var myNonce;
    var expectingMoreData = false;
    var obj;
    var requestSucceeded = false;

    var authClientSocket = net.connect({host: options.newAuthHost, port: options.newAuthPort}, 
        function() {
            console.log('connected to auth! from local port ' + authClientSocket.localPort);
    });
    function onEnd() {
        authClientSocket.end();
    }
    function onError(error) {
        authClientSocket.end();
        // TODO: use this later
        //console.log('error: ' + error);
        eventHandlers.onError('Error occurred in migration request: ' + error);
    }
    function onWrite(buf) {
        authClientSocket.write(buf);
    }
    function authHelloTimeoutHandler() {
        onError('Auth hello timedout ...');
    }
    authHelloTimeout = setTimeout(authHelloTimeoutHandler, options.connectionTimeout);
    
    var helperEventHandlers = {
        onEnd: onEnd,
        onWrite: onWrite,
        onError: onError
    };

    authClientSocket.on('data', function(data) {
        if (!expectingMoreData) {
            obj = common.parseIoTSP(data);
            if (obj.payload.length < obj.payloadLen) {
                expectingMoreData = true;
                console.log('more data will come. current: ' + obj.payload.length
                    + ' expected: ' + obj.payloadLen);
            }
        }
        else {
            obj.payload = Buffer.concat([obj.payload, data]);
            if (obj.payload.length ==  obj.payloadLen) {
                expectingMoreData = false;
            }
            else {
                console.log('more data will come. current: ' + obj.payload.length
                    + ' expected: ' + obj.payloadLen);
            }
        }

        // Test code
        //sleep.sleep(1);

        if (expectingMoreData) {
            // do not process the packet yet
            return;
        }
        else {
            var helperOptions = {
                msgType: obj.msgType,
                payload: obj.payload,
                myNonce: myNonce
            };
            var ret = sendMigrationReqHelper(helperOptions, helperEventHandlers, options, migrationRespHandler);
            if (!ret.success) {
                onError(ret.error);
                //authClientSocket.end();
                //eventHandlers.onError(ret.error);
                return;
            }
            requestSucceeded = true;
            myNonce = ret.myNonce;
        }
    });
    authClientSocket.on('error', function(error) {
        eventHandlers.onError('Error occurred in migration request: ' + error);
    });
    authClientSocket.on('end', function() {
        if (!requestSucceeded) {
            eventHandlers.onError('Error occurred in migration request: Disconnected from auth before getting migration response: ' + error);
        }
        else {
            console.log('disconnected from auth');
        }
    });
};
