/*
 * Copyright (c) 2016, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * IOTAUTH_COPYRIGHT_VERSION_1
 */

/**
 * Global common file for example entities.
 * @author Hokeun Kim
 */

"use strict";

var crypto = require('crypto');
var constants = require('constants');
const {Uint64BE} = require('int64-buffer');

// global variables
exports.SESSION_KEY_ID_SIZE = 8;
exports.SEQ_NUM_SIZE = 8;

exports.msgType = {
    AUTH_HELLO: 0,
    ENTITY_HELLO: 1,
    AUTH_SESSION_KEY_REQ: 10,
    AUTH_SESSION_KEY_RESP: 11,
    SESSION_KEY_REQ_IN_PUB_ENC: 20,
    SESSION_KEY_RESP_WITH_DIST_KEY: 21,    // Includes distribution message (session keys)
    SESSION_KEY_REQ: 22,        // Distribution message
    SESSION_KEY_RESP: 23,        // Distribution message
    SKEY_HANDSHAKE_1: 30,
    SKEY_HANDSHAKE_2: 31,
    SKEY_HANDSHAKE_3: 32,
    SECURE_COMM_MSG: 33,
    FIN_SECURE_COMM: 34,
    SECURE_PUB: 40,
    MIGRATION_REQ_WITH_SIGN: 50,
    MIGRATION_RESP_WITH_SIGN: 51,
    MIGRATION_REQ_WITH_MAC: 52,
    MIGRATION_RESP_WITH_MAC: 53,
    AUTH_ALERT: 100
};

exports.getCryptoKeySize = function(cryptoAlgorithm) {
    if (cryptoAlgorithm.toUpperCase().startsWith('AES-128')) {
        return 16;
    }
    else if (cryptoAlgorithm.toUpperCase().startsWith('AES-192')) {
        return 24;
    }
    else if (cryptoAlgorithm.toUpperCase().startsWith('AES-256')) {
        return 32;
    }
    else if (cryptoAlgorithm.toUpperCase().startsWith('DES')) {
        return 7;
    }
    else if (cryptoAlgorithm.toUpperCase() === 'SHA256') {
        return 32;
    }
    else if (cryptoAlgorithm.toUpperCase() === 'SHA1') {
        return 20;
    }
    else {
        throw 'Error: crypto NOT supported: ' + cryptoAlgorithm;
    }
}

function getCipherIvSize(cipherAlgorithm) {
    if (cipherAlgorithm.toUpperCase().startsWith('AES')) {
        return 16;
    }
    else if (cipherAlgorithm.toUpperCase().startsWith('DES')) {
        return 8;
    }
    else {
        throw 'Error: cipher NOT supported: ' + cipherAlgorithm;
    }
};

function getMacSize(macAlgorithm) {
    if (!macAlgorithm) {
        // No MAC algorithm defined (e.g. AES-128-GCM)
        return 0;
    }
    else if (macAlgorithm.toUpperCase() === 'SHA256') {
        return 32;
    }
    else if (macAlgorithm.toUpperCase() === 'SHA1') {
        return 20;
    }
};

// verialbe length integer encoding
exports.numToVarLenInt = function(num) {
    var buf = Buffer.alloc(0);
    while (num > 127) {
        var extraBuf = Buffer.alloc(1);
        extraBuf.writeUInt8(128 | num & 127);
        buf = Buffer.concat([buf, extraBuf]);
        num >>= 7;
    }
    var extraBuf = Buffer.alloc(1);
    extraBuf.writeUInt8(num);
    buf = Buffer.concat([buf, extraBuf]);
    return buf;
};

exports.varLenIntToNum = function(buf, offset) {
    var num = 0;
    for (var i = 0; i < buf.length; i++) {
        num |= (buf[offset + i] & 127) << (7 * i);
        if ((buf[offset + i] & 128) == 0) {
            return {num: num, bufLen: i + 1};
            break;
        }
    }
    return null;
};

// Support for readUIntBE for buffer with more than 6 bytes.
exports.readVariableUIntBE = function(buf, offset, byteLength) {
    if (byteLength <= 6) {
        return buf.readUIntBE(offset, byteLength);
    } else {
        return Uint64BE(buf.slice(offset, byteLength)).toNumber();
    }
};

// Support for writeUIntBE for buffer with more than 6 bytes.
exports.writeVariableUIntBE = function(buf, value, offset, byteLength) {
    if (byteLength <= 6) {
        buf.writeUIntBE(value, offset, byteLength);
    } else {
        const big = new Uint64BE(value);
        const bigBuf = big.toBuffer();
        bigBuf.copy(buf, offset, 0, byteLength);
    }
};

// for authenticate only
exports.symmetricAuthenticateAttach = function(buf, symmetricKeySet, symmetricCryptoSpec) {
    var hmac = crypto.createHmac(symmetricCryptoSpec.mac, symmetricKeySet.macKeyVal);
    hmac.update(buf);
    var tag = hmac.digest();
    return Buffer.concat([buf, tag]);
}

exports.symmetricVerifyExtract = function(buf, symmetricKeySet, symmetricCryptoSpec) {
    var macSize = getMacSize(symmetricCryptoSpec.mac);
    var data = buf.slice(0, buf.length - macSize);
    var receivedTag = buf.slice(buf.length - macSize);
    var hmac = crypto.createHmac(symmetricCryptoSpec.mac, symmetricKeySet.macKeyVal);
    hmac.update(data);
    var computedTag = hmac.digest();
    if (!computedTag.equals(receivedTag)) {
        throw 'Invalid MAC error!';
    }
    return data;
}

// for encrypt and authenticate
exports.symmetricEncryptAuthenticate = function(buf, symmetricKeySet, symmetricCryptoSpec)
{
    var iv = Buffer.from(crypto.randomBytes(getCipherIvSize(symmetricCryptoSpec.cipher)));
    var cipher = crypto.createCipheriv(symmetricCryptoSpec.cipher, symmetricKeySet.cipherKeyVal, iv);
    var enc = cipher.update(buf);
    enc = Buffer.concat([iv, enc, cipher.final()]);

    var hmac = crypto.createHmac(symmetricCryptoSpec.mac, symmetricKeySet.macKeyVal);
    hmac.update(enc);
    var tag = hmac.digest();
    // TEST: generating error in encrypted data
    //tag.writeUInt8(4, tag.length - 4);
    return Buffer.concat([enc, tag]);
};

// returns {hashOk: bool, data: Buffer}
exports.symmetricDecryptAuthenticate = function(buf, symmetricKeySet, symmetricCryptoSpec)
{
    var macSize = getMacSize(symmetricCryptoSpec.mac);
    var enc = buf.slice(0, buf.length - macSize);
    var receivedTag = buf.slice(buf.length - macSize);
    var hmac = crypto.createHmac(symmetricCryptoSpec.mac, symmetricKeySet.macKeyVal);
    hmac.update(enc);
    var computedTag = hmac.digest();
    if (!computedTag.equals(receivedTag)) {
        throw 'Invalid MAC error!';
    }

    var ivSize = getCipherIvSize(symmetricCryptoSpec.cipher);
    var iv = enc.slice(0, ivSize);
    var decipher = crypto.createDecipheriv(symmetricCryptoSpec.cipher, symmetricKeySet.cipherKeyVal, iv);
    // Turn off auto padding to work with an entity written in C language.
    decipher.setAutoPadding(false);
    var dec = decipher.update(enc.slice(ivSize));
    return Buffer.concat([dec, decipher.final()]);
};


/*
    SecureSessionMessage Format
    {
        SeqNum: /Buffer/, // UIntBE, SEQ_NUM_SIZE Bytes
        data: /Buffer/,
    }
*/
exports.serializeEncryptSessionMessage = function(obj, sessionKey, sessionCryptoSpec) {
    if (obj.seqNum == undefined || obj.data == undefined) {
        console.log('Error: Secure session message seqNum or data is missing.');
        return;
    }
    var seqNumBuf = Buffer.alloc(exports.SEQ_NUM_SIZE);
    exports.writeVariableUIntBE(seqNumBuf, obj.seqNum, 0, exports.SEQ_NUM_SIZE);
    var buf = Buffer.concat([seqNumBuf, obj.data]);
    return exports.symmetricEncryptAuthenticate(buf, sessionKey, sessionCryptoSpec);
};

exports.parseDecryptSessionMessage = function(buf, sessionKey, sessionCryptoSpec) {
        var decBuf = exports.symmetricDecryptAuthenticate(buf, sessionKey, sessionCryptoSpec);
        var seqNum = exports.readVariableUIntBE(decBuf, 0, exports.SEQ_NUM_SIZE);
        var data = decBuf.slice(exports.SEQ_NUM_SIZE);
        return {seqNum: seqNum, data: data};
};

exports.parseSessionMessage = function(buf) {
        var seqNum = exports.readVariableUIntBE(buf, 0, exports.SEQ_NUM_SIZE);
        var data = buf.slice(exports.SEQ_NUM_SIZE);
        return {seqNum: seqNum, data: data};
};

exports.serializeStringParam = function(stringParam) {
    var result;
    if (stringParam == null) {
        result = exports.numToVarLenInt(0);
    }
    else {
        var strLenBuf = exports.numToVarLenInt(stringParam.length);
        var strBuf = Buffer.alloc(stringParam.length);
        strBuf.write(stringParam, 0);
        result = Buffer.concat([strLenBuf, strBuf]);
    }
    return result;
};

exports.parseStringParam = function(buf, offset) {
    var ret = exports.varLenIntToNum(buf, offset);
    if (ret.bufLen == 0) {
        return {len: 1, str: null};
    }
    var strLen = ret.num;
    var str = buf.toString('utf8', offset + ret.bufLen, offset + ret.bufLen + strLen);
    return {len: ret.bufLen + strLen, str: str};
};

/*
    IoTSP (IoT Secure Protocol) Message
    {
        msgType: /UInt8/,
        payloadLen: /variable-length integer encoding/
        payload: /Buffer/
    }
*/
exports.serializeIoTSP = function(obj) {
    if (obj.msgType == undefined || obj.payload == undefined) {
        console.log('Error: IoTSP msgType or payload is missing.');
        return;
    }
    var msgTypeBuf = Buffer.alloc(1);
    msgTypeBuf.writeUInt8(obj.msgType, 0);
    var payLoadLenBuf = exports.numToVarLenInt(obj.payload.length);
    return Buffer.concat([msgTypeBuf, payLoadLenBuf, obj.payload]);
};

exports.parseIoTSP = function(buf) {
    var msgTypeVal = buf.readUInt8(0);
    var ret = exports.varLenIntToNum(buf, 1);
    var payloadVal = buf.slice(1 + ret.bufLen);
    return {msgType: msgTypeVal, payloadLen: ret.num, payload: payloadVal};
};

/*
    SignedMsg Format
    {
        data: /Buffer/,
        signature: /Buffer/   RSA_KEY_SIZE
    }
*/
exports.signAndAttach = function(buf, privateKey, publicKeyCryptoSpec) {
    var sign = crypto.createSign(publicKeyCryptoSpec.sign);
    sign.update(buf);
    var signature = sign.sign(privateKey);

    return Buffer.concat([buf, signature]);
};

// returns {signature: buffer, data: buffer}
exports.parseSignedData = function(buf, publicKeyCryptoSpec) {
    var data = buf.slice(0, buf.length - publicKeyCryptoSpec.keySize);
    var signature = buf.slice(buf.length - publicKeyCryptoSpec.keySize);
    return {signature:signature, data: data};
};

// returns {verified: bool, buf: Buffer}
exports.verifySignedData = function(buf, publicKey, publicKeyCryptoSpec) {
    var ret = exports.parseSignedData(buf, publicKeyCryptoSpec);
    var verifier = crypto.createVerify(publicKeyCryptoSpec.sign);
    verifier.update(ret.data);
    if (!verifier.verify(publicKey, ret.signature, 'hex')) {
        return {verified: false};
    }
    return {verified: true, buf: ret.data};
};

//var RSA_KEY_SIZE = 256;       // 2048 bits
//var MAX_PUB_ENC_BYTES = RSA_KEY_SIZE - 42; // 256 Bytes - 42 Bytes OAEP Padding = max 214 Bytes

exports.publicEncryptAndSign = function(buf, pubDest, privateKey, publicKeyCryptoSpec) {
    var MAX_PUB_ENC_BYTES = publicKeyCryptoSpec.keySize - 11; // 256 Bytes - 11 Bytes PKCS#1 Padding = max 245 Bytes
    if (buf.length <= MAX_PUB_ENC_BYTES) {
        var encBuf = crypto.publicEncrypt({key: pubDest, padding: crypto.constants[publicKeyCryptoSpec.padding]}, buf);
        return exports.signAndAttach(encBuf, privateKey, publicKeyCryptoSpec);
    }
    else {
        throw "Data for public encryption is too big!"
    }
};

exports.getPublicEncryptedAndSignedMessageSize = function(publicKeyCryptoSpec) {
    return publicKeyCryptoSpec.keySize * 2;     // only for RSA
}

exports.privateDecrypt = function(buf, privateKey, publicKeyCryptoSpec) {
    if (buf.length <= publicKeyCryptoSpec.keySize) {
        return crypto.privateDecrypt({key: privateKey, padding: crypto.constants[publicKeyCryptoSpec.padding]}, buf);
    }
    else {
        throw "Data for private decryption is too big!"
    }
};

// update current symmetric key with key derived from Diffie-Hellman key exchange
exports.updateSymmetricKeyWithKeyFromDH = function(symmetricKeySet, newSymmetricKeyValue) {
    var cipherKeyLength = symmetricKeySet.cipherKeyVal.length;
    var macKeyLength = symmetricKeySet.macKeyVal.length;
    // to copy other key information (e.g., validity periods)
    var newSymmetricKeySet = symmetricKeySet;
    newSymmetricKeySet.cipherKeyVal = newSymmetricKeyValue.slice(0, cipherKeyLength);
    newSymmetricKeySet.macKeyVal = newSymmetricKeyValue.slice(cipherKeyLength, cipherKeyLength + macKeyLength);
    return newSymmetricKeySet;
}

var HS_NONCE_SIZE = 8;            // default handshake nonce size

// generate handshake nonce
exports.generateHSNonce = function() {
    return crypto.randomBytes(HS_NONCE_SIZE);
};

/*
    Handshake Format
    {
        indicator: /UInt8/, // ind[0] = nonce?, ind[1] = replyNonce?, ind[2] = dhParam?
        nonce: /Buffer/, // encrypted, may be undefined
        replyNonce: /Buffer/, // encrypted, may be undefined,
        dhParam: /Buffer/, // Diffie-Hellman parameter (optional)
    }
*/
exports.serializeHandshake = function(obj) {
    if (obj.nonce == undefined && obj.replyNonce == undefined) {
        console.log('Error: handshake should include at least on nonce.');
        return;
    }

    var buf = Buffer.alloc(1 + HS_NONCE_SIZE * 2);

    // indicates existence of nonces
    var indicator = 0;
    if (obj.nonce != undefined) {
        indicator += 1;
        obj.nonce.copy(buf, 1);
    }
    if (obj.replyNonce != undefined) {
        indicator += 2;
        obj.replyNonce.copy(buf, 1 + HS_NONCE_SIZE);
    }
    if (obj.dhParam != undefined) {
        indicator += 4;
        buf = Buffer.concat([buf, obj.dhParam]);
    }

    buf.writeUInt8(indicator, 0);

    return buf;
};

// buf should be just the unencrypted part
exports.parseHandshake = function(buf) {
    var obj = {};
    var indicator = buf.readUInt8(0);
    if ((indicator & 1) != 0) {
        // nonce exists
        obj.nonce = buf.slice(1, 1 + HS_NONCE_SIZE);
    }
    if ((indicator & 2) != 0) {
        // replayNonce exists
        obj.replyNonce = buf.slice(1 + HS_NONCE_SIZE, 1 + HS_NONCE_SIZE * 2);
    }
    if ((indicator & 4) != 0) {
        obj.dhParam = buf.slice(1 + HS_NONCE_SIZE * 2);
    }
    return obj;
};