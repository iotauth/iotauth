/*
 * Copyright (c) 2016, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * IOTAUTH_COPYRIGHT_VERSION_1
 */

/**
 * IoT secure server helper module.
 * @author Hokeun Kim
 */

"use strict";

var net = require('net');
var dgram = require('dgram');
var crypto = require('crypto');
var util = require('util');

// local modules
var common = require('./common');
var msgType = common.msgType;
var IoTSecureSocket = require('./iotSecureSocket');

///////////////////////////////////////////////////////////////////
////                Functions for entity server                ////

var entityServerCommState = {
    IDLE: 0,
    WAITING_SESSION_KEY: 20,
    HANDSHAKE_1_RECEIVED: 21,
    HANDSHAKE_2_SENT: 22,
    IN_COMM: 30                    // Session message
};
/*
helperOptions = {
    msgType,
    payload,
    myNonce,
    entityServerState,
    entityServerSessionKey,
    serverECDH,
    iotSecureSocket,
    socketID
}
*/
/*
helperEventHandlers = {
    onWrite,
    onEnd,
    onUpdate(update),
    onConnection
}
*/
/*
update = {
    myNonce,
    entityServerState,
    entityServerSessionKey,
    serverECDH
}
*/
var handshakeTimeout = null;
function secureServerHelper(helperOptions, helperEventHandlers, options, eventHandlers) {
    function sendHandshake2(handshake1Payload, serverSocket, sessionKey) {
        if (helperOptions.entityServerState != entityServerCommState.HANDSHAKE_1_RECEIVED) {
            eventHandlers.onServerError('Error during comm init - in wrong state, expected: HANDSHAKE_1_RECEIVED, disconnecting...');
            helperEventHandlers.onEnd();
            return;
        }

        var enc = handshake1Payload.slice(common.SESSION_KEY_ID_SIZE);
        var update = {};
        update.entityServerSessionKey = sessionKey;

        var buf = common.symmetricDecryptAuthenticate(enc, update.entityServerSessionKey, options.sessionCryptoSpec);

        var ret = common.parseHandshake(buf);
        var theirNonce = ret.nonce;

        console.log('server ret: ' + util.inspect(ret));

        update.myNonce = common.generateHSNonce();
        console.log('chosen nonce: ' + update.myNonce.inspect());
        var handshake2 = {nonce: update.myNonce, replyNonce: theirNonce};

        if (options.sessionCryptoSpec.diffieHellman) {
            console.log('Using Diffie-Hellman algorithm: ' + options.sessionCryptoSpec.diffieHellman);
            update.serverECDH = crypto.createECDH(options.sessionCryptoSpec.diffieHellman);
            handshake2.dhParam = update.serverECDH.generateKeys();
        }

        buf = common.serializeHandshake(handshake2);
        enc = common.symmetricEncryptAuthenticate(buf, update.entityServerSessionKey, options.sessionCryptoSpec);
        var msg = {
            msgType: msgType.SKEY_HANDSHAKE_2,
            payload: enc
        };
        helperEventHandlers.onWrite(common.serializeIoTSP(msg));
        console.log('switching to HANDSHAKE_2_SENT');
        update.entityServerState = entityServerCommState.HANDSHAKE_2_SENT;
        helperEventHandlers.onUpdate(update);
    };
    function handshakeTimeoutHandler() {
        handshakeTimeout = null;
        helperEventHandlers.onError('handshake2 timed out...');
    }
    if (helperOptions.msgType == msgType.SKEY_HANDSHAKE_1) {
        console.log('received session key handshake1');
        if (helperOptions.entityServerState != entityServerCommState.IDLE) {
            eventHandlers.onServerError('Error during comm init - in wrong state, expected: IDLE, disconnecting...');
            helperEventHandlers.onEnd();
            return;
        }
        console.log('switching to HANDSHAKE_1_RECEIVED state.');
        helperOptions.entityServerState = entityServerCommState.HANDSHAKE_1_RECEIVED;
        helperEventHandlers.onUpdate({entityServerState: helperOptions.entityServerState});
        eventHandlers.onClientRequest(helperOptions.payload, helperOptions.entityServerSocket, sendHandshake2);
        if (options.handshakeTimeout == null) {
            throw 'handshake timeout is not set!';
        }
        handshakeTimeout = setTimeout(handshakeTimeoutHandler, options.handshakeTimeout);
    }
    else if (helperOptions.msgType == msgType.SKEY_HANDSHAKE_3) {
        if (handshakeTimeout) {
            clearTimeout(handshakeTimeout);
            handshakeTimeout = null;
        }
        console.log('received session key handshake3!');
        if (helperOptions.entityServerState != entityServerCommState.HANDSHAKE_2_SENT) {
            console.log('Error: wrong sequence of handshake, disconnecting...');
            helperEventHandlers.onUpdate({entityServerState: entityServerCommState.IDLE});
            helperEventHandlers.onEnd();
            return;
        }
        var buf = common.symmetricDecryptAuthenticate(helperOptions.payload, helperOptions.entityServerSessionKey, options.sessionCryptoSpec);
        var ret = common.parseHandshake(buf);
        console.log(ret);

        if (helperOptions.myNonce.equals(ret.replyNonce)) {
            console.log('client authenticated/authorized by solving nonce!');
        }
        else {
            console.log('Error: client NOT verified, nonce NOT matched, disconnecting...');
            helperEventHandlers.onUpdate({entityServerState: entityServerCommState.IDLE});
            helperEventHandlers.onEnd();
            return;
        }

        if (options.sessionCryptoSpec.diffieHellman) {
            var newSessionKeyVal = helperOptions.serverECDH.computeSecret(ret.dhParam);
            console.log(newSessionKeyVal);
            helperEventHandlers.onConnection(newSessionKeyVal);
            return;
        }
        helperEventHandlers.onConnection();
    }
    else if (helperOptions.msgType == msgType.SECURE_COMM_MSG) {
        console.log('received secure communication!');
        if (helperOptions.entityServerState != entityServerCommState.IN_COMM) {
            console.log('Error: it is not in IN_COMM state, disconnecting...');
            helperEventHandlers.onUpdate({entityServerState: entityServerCommState.IDLE});
            helperEventHandlers.onEnd();
            return;
        }
        var ret = helperOptions.iotSecureSocket.receive(helperOptions.payload);
        if (!ret.success) {
            eventHandlers.onError(ret.error, helperOptions.socketID);
            return;
        }
        eventHandlers.onData(ret.data, helperOptions.socketID);
    }
    else if (helperOptions.msgType == msgType.FIN_SECURE_COMM && options.sessionProtocol === 'UDP') {
        console.log('received fin secure communication on UDP!');
        if (helperOptions.entityServerState != entityServerCommState.IN_COMM) {
            console.log('Error: it is not in IN_COMM state, disconnecting...');
            helperEventHandlers.onUpdate({entityServerState: entityServerCommState.IDLE});
            return;
        }
        console.log('switching to IDLE...');
        helperEventHandlers.onUpdate({entityServerState: entityServerCommState.IDLE});
    }
    else {
        console.error('received unknown type of message! ' + helperOptions.msgType);
    }
}

exports.initializeSecureServerOnTCP = function(options, eventHandlers) {
    var connectionCount = 0;
    var entityServer = net.createServer(function(entityServerSocket) {
        console.log('Unidentified client connected');
        var entityServerState = entityServerCommState.IDLE;
        var myNonce;
        var entityServerSessionKey;
        var serverECDH;
        var socketID = -1;

        function onEnd() {
            if (entityServerSocket != null) {
                entityServerSocket.end();
                entityServerSocket = null;    
            }
        }
        function onError(error) {
            eventHandlers.onServerError(error);
        }
        function onWrite(buf) {
            entityServerSocket.write(buf);
        }
        function onConnection(newSessionKeyVal) {
            if (newSessionKeyVal != null) {
                entityServerSessionKey = common.updateSymmetricKeyWithKeyFromDH(entityServerSessionKey, newSessionKeyVal);
                console.log('new session key: ' + util.inspect(entityServerSessionKey));
            }
            console.log('switching to IN_COMM');
            entityServerState = entityServerCommState.IN_COMM;
            var entityServerSocketEventHandlers = {
                onEnd: onEnd,
                onWrite: onWrite
            }
            iotSecureSocket = new IoTSecureSocket(entityServerSocketEventHandlers, entityServerSessionKey,
                options.sessionCryptoSpec);
            socketID = connectionCount++;
            var socketInstance = {
                'id': socketID,
                'remoteAddress': entityServerSocket.remoteAddress + ':' + entityServerSocket.remotePort,
                'status': 'open'
            };
            eventHandlers.onConnection(socketInstance, iotSecureSocket);
        }
        function onUpdate(update) {
            if (update.myNonce != null) {
                myNonce = update.myNonce;
            }
            if (update.entityServerState != null) {
                entityServerState = update.entityServerState;
            }
            if (update.entityServerSessionKey != null) {
                entityServerSessionKey = update.entityServerSessionKey;
            }
            if (update.serverECDH != null) {
                serverECDH = update.serverECDH;
            }
        }
        var helperEventHandlers = {
            onWrite: onWrite,
            onEnd: onEnd,
            onError: onError,
            onConnection: onConnection,
            onUpdate: onUpdate
        }
        entityServerSocket.on('end', function() {
            console.log('Unidentified client disconnected');
        });

        entityServerSocket.on('end', function() {
            if (entityServerState == entityServerCommState.IN_COMM) {
                eventHandlers.onClose(socketID);
                return;
            }
            else {
                if (entityServerSocket == null) {
                    eventHandlers.onServerError('Unidentified client disconnected');
                }
                else {
                    eventHandlers.onServerError('Closed during comm init from ' +
                        entityServerSocket.remoteAddress + ':' + entityServerSocket.remotePort);
                }
                return;
            }
        });
        
        entityServerSocket.on('error', function(message) {
            if (entityServerState == entityServerCommState.IN_COMM) {
                eventHandlers.onError(message, socketID);
                return;
            }
            else {
                eventHandlers.onServerError('Error during comm init, details: ' + message);
                return;
            }
        });

        var obj;
        var expectingMoreData = false;
        var iotSecureSocket = null;
        var remainingPayload = null;
        entityServerSocket.on('data', function(data) {
            if (!expectingMoreData) {
                obj = common.parseIoTSP(data);
                if (obj.payload.length < obj.payloadLen) {
                    expectingMoreData = true;
                    console.log('more data will come. current: ' + obj.payload.length
                        + ' expected: ' + obj.payloadLen);
                }
                else if(obj.payloadLen < obj.payload.length) {
                    remainingPayload = obj.payload.slice(obj.payloadLen);
                    obj.payload = obj.payload.slice(0, obj.payloadLen);
                }
            }
            else {
                obj.payload = Buffer.concat([obj.payload, data]);
                if (obj.payload.length ==  obj.payloadLen) {
                    expectingMoreData = false;
                }
                else {
                    console.log('more data will come. current: ' + obj.payload.length
                        + ' expected: ' + obj.payloadLen);
                }
            }

            if (expectingMoreData) {
                // do not process the packet yet
                return;
            }
            var helperOptions = {
                msgType: obj.msgType,
                payload: obj.payload,
                myNonce: myNonce,
                entityServerState: entityServerState,
                entityServerSessionKey: entityServerSessionKey,
                serverECDH: serverECDH,
                iotSecureSocket: iotSecureSocket,
                socketID: socketID
            };
            try {
                secureServerHelper(helperOptions, helperEventHandlers, options, eventHandlers);
                if(remainingPayload != null){
                    var tempData = remainingPayload;
                    remainingPayload = null;
                    entityServerSocket.emit('data', tempData);
                }
            }
            catch (err) {
                eventHandlers.onServerError('Exception occurred: ' + err);
            }
        });
    });
    entityServer.on('error', function(message) {
        eventHandlers.onServerError(message);
    });
    entityServer.listen(options.serverPort, eventHandlers.onServerListening);
}

exports.initializeSecureServerOnUDP = function(options, eventHandlers) {
    var udpServerSocket = dgram.createSocket('udp4');
    var entityServerState = entityServerCommState.IDLE;
    var myNonce;
    var entityServerSessionKey;
    var serverECDH;
    var socketID = -1;
    var iotSecureSocket = null;
    udpServerSocket.on('error', (err) => {
        console.log('server error:\n' + err.stack);
        udpServerSocket.close();
    });

    udpServerSocket.on('message', (data, rinfo) => {
        function onEnd() {
            udpServerSocket.close();
        }
        function onError(error) {
            eventHandlers.onServerError(error);
            entityServerState = entityServerCommState.IDLE;
        }
        function onWrite(buf) {
            udpServerSocket.send(buf, 0, buf.length, rinfo.port, rinfo.address, (err) => {
                if (err) {
                    console.error('udp server error: ' + err);
                }
                //socket.close();
            });
        }
        function onUpdate(update) {            
            if (update.myNonce != null) {
                myNonce = update.myNonce;
            }
            if (update.entityServerState != null) {
                entityServerState = update.entityServerState;
            }
            if (update.entityServerSessionKey != null) {
                entityServerSessionKey = update.entityServerSessionKey;
            }
            if (update.serverECDH != null) {
                serverECDH = update.serverECDH;
            }
        }
        function onConnection(newSessionKeyVal) {
            if (newSessionKeyVal != null) {
                // TODO: Update macKeyVal as well using DH exchange
                entityServerSessionKey.cipherKeyVal = newSessionKeyVal;
            }
            console.log('switching to IN_COMM');
            entityServerState = entityServerCommState.IN_COMM;
            var entityServerSocketEventHandlers = {
                onEnd: onEnd,
                onWrite: onWrite
            }
            iotSecureSocket = new IoTSecureSocket(entityServerSocketEventHandlers, entityServerSessionKey,
                options.sessionCryptoSpec);
            //socketID = connectionCount++;
            var address = udpServerSocket.address();
            var socketInstance = {
                'id': 0,
                'remoteAddress': address.address + ':' + address.port,
                'status': 'open'
            };
            eventHandlers.onConnection(socketInstance, iotSecureSocket);

        }
        var helperEventHandlers = {
            onEnd: onEnd,
            onError: onError,
            onWrite: onWrite,
            onUpdate: onUpdate,
            onConnection: onConnection
        };

        console.log('some message received?');
        console.log('Received %d bytes from %s:%d\n', data.length, rinfo.address, rinfo.port);

        var obj = common.parseIoTSP(data);
        if (obj.payload.length != obj.payloadLen) {
            console.error('wrong payload length: ' + obj.payload.length + ' should be: ' + obj.payloadLen);
            return;
        }
        var helperOptions = {
            msgType: obj.msgType,
            payload: obj.payload,
            myNonce: myNonce,
            entityServerState: entityServerState,
            entityServerSessionKey: entityServerSessionKey,
            serverECDH: serverECDH,
            iotSecureSocket: iotSecureSocket,
            socketID: socketID
        };
        try {
            secureServerHelper(helperOptions, helperEventHandlers, options, eventHandlers);
        }
        catch (err) {
            eventHandlers.onServerError('Exception occurred: ' + err);
        }
    });

    udpServerSocket.on('listening', () => {
        var address = udpServerSocket.address();
        console.log(address);
        console.log('server listening ' + address.address + ':' + address.port);
        eventHandlers.onServerListening();
    });

    udpServerSocket.bind(options.serverPort);
}
